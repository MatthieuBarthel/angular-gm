<h1><code ng:non-bindable="">gmMarkers</code>
<span class="hint">(directive in module <code ng:non-bindable="">angulargm</code>
)</span>
</h1>
<div><h2 id="Description">Description</h2>
<div class="description"><p>A directive for adding markers to a <code>gmMap</code>. You may have multiple per <code>gmMap</code>.</p>

<p>To use, you specify an array of custom objects and tell the directive how to
extract an id and position from them. A marker will be created for each of
your objects. If you assign a new array to your scope variable or change the
array's length (i.e. add or remove an object), the markers will also update.
The one case where <code>gmMarkers</code> can not automatically detect changes to your
objects is when you mutate objects in the array. To inform the directive of
such changes, see the <code>gmMarkersUpdate</code> event below.</p>

<p>Only the <code>gm-objects</code>, <code>gm-id</code> and <code>gm-position</code> attributes are required.</p></div>
<h2 id="Usage">Usage</h2>
<div class="usage">as attribute<pre class="prettyprint linenums">&lt;ANY gm-markers
     gm-objects="{expression}"
     gm-id="{expression}"
     gm-position="{expression}"
     gm-marker-options="{expression}"
     gm-events="{expression}"
     gm-on-*event*="{expression}"&gt;
   ...
&lt;/ANY&gt;</pre>
as class<pre class="prettyprint linenums">&lt;ANY class="gm-markers gm-objects: {expression}; gm-id: {expression}; gm-position: {expression}; gm-marker-options: {expression}; gm-events: {expression}; gm-on-*event*: {expression};"&gt;
   ...
&lt;/ANY&gt;</pre>
<h3 id="Parameters">Parameters</h3>
<ul class="parameters"><li><code ng:non-bindable="">gm-objects – {expression} – </code>
<p>an array of objects in the current scope.
These can be any objects you wish to attach to markers, the only requirement
is that they have a uniform method of accessing an id and a position.</p></li>
<li><code ng:non-bindable="">gm-id – {expression} – </code>
<p>an angular expression that given an object from
<code>gm-objects</code>, evaluates to a unique identifier for that object. Your object
can be accessed through the variable <code>object</code>. See <code>gm-position</code> below for
an example.</p></li>
<li><code ng:non-bindable="">gm-position – {expression} – </code>
<p>an angular expression that given an object from
<code>gm-objects</code>, evaluates to an object with lat and lng properties. Your
object can be accessed through the variable <code>object</code>.  For example, if
your controller has</p>

<pre><code class="js">...
$scope.myObjects = [
  { id: 0, location: { lat: 5, lng: 5} }, 
  { id: 1, location: { lat: 6, lng: 6} }
]
...
</code></pre>

<p>then in the <code>gm-markers</code> directive you would put</p>

<pre><code class="js">...
gm-objects="myObjects"
gm-id="object.id"
gm-position="{ lat: object.location.lat, lng: object.location.lng }"
...
</code></pre></li>
<li><code ng:non-bindable="">gm-marker-options – {expression} – </code>
<p>an angular expression that given
an object from <code>gm-objects</code>, evaluates to a
<a href="https://developers.google.com/maps/documentation/javascript/reference#MarkerOptions">google.maps.MarkerOptions</a>
object.  Your object can be accessed through the variable <code>object</code>. If
unspecified, google maps api defaults will be used.</p></li>
<li><code ng:non-bindable="">gm-events – {expression} – </code>
<p>a variable in the current scope that is used to
simulate events on markers. Setting this variable to an object of the form </p>

<pre><code class="js">    [
      {
        event: 'click',
        ids: [id1, ...]
      },
      ...
    ]
</code></pre>

<p>will generate the named events on the markers with the given ids, if a
marker with each id exists. Note: when setting the <code>gm-events</code> variable, you
must set it to a new object for the changes to be detected.  Code like</p>

<pre><code class="js">myEvents[0]["ids"] = [0]
</code></pre>

<p>
will not work.</p></li>
<li><code ng:non-bindable="">gm-on-*event* – {expression} – </code>
<p>an angular expression which evaluates to
an event handler. This handler will be attached to each marker's *event*
event.  The variables 'object' and 'marker' evaluate to your object and the
<a href="https://developers.google.com/maps/documentation/javascript/reference#Marker">google.maps.Marker</a>,
respectively. For example: </p>

<pre><code class="html">gm-on-click="myClickFn(object, marker)"
</code></pre>

<p>will call your <code>myClickFn</code> whenever a marker is clicked.  You may have
multiple <code>gm-on-*event*</code> handlers, but only one for each type of event.
For events that have an underscore in their name, such as
'position_changed', write it as 'gm-on-position-changed'.</p></li>
</ul>
</div>
<div class="member event"><h2 id="Events">Events</h2>
<ul class="events"><li><h3 id="gmMarkersRedraw">gmMarkersRedraw</h3>
<div class="gmmarkersredraw"><p>Force the <code>gmMarkers</code> directive to clear and redraw all markers.</p><div class="inline"><h4 id="Listen.on.">Listen on:</h4>
<div class="listen-on-">current gmMarkers scope</div>
</div>
<h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">objects – {string} – </code>
<p>Not required. The name of the scope variable which
holds the objects to redraw markers for, i.e. what you set <code>gm-objects</code> to.
It is useful because there may be multiple instances of the <code>gmMarkers</code>
directive. If not specified, all instances of <code>gmMarkers</code> which are child
scopes will redraw their markers.</p></li>
</ul>
<h4 id="Example">Example</h4>
<div class="example"><pre><code class="js">$scope.$broadcast('gmMarkersRedraw', 'myObjects');
</code></pre></div>
</div>
</li>
<li><h3 id="gmMarkersUpdate">gmMarkersUpdate</h3>
<div class="gmmarkersupdate"><p>Manually tell the <code>gmMarkers</code> directive to update the markers.
This is useful to tell the directive when an object from <code>gm-objects</code> is
mutated--<code>gmMarkers</code> can not pick up on such changes automatically.</p><div class="inline"><h4 id="Listen.on.">Listen on:</h4>
<div class="listen-on-">current gmMarkers scope</div>
</div>
<h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">objects – {string} – </code>
<p>Not required. The name of the scope variable which
holds the objects to update markers for, i.e. what you set <code>gm-objects</code> to.
It is useful because there may be multiple instances of the <code>gmMarkers</code>
directive. If not specified, all instances of <code>gmMarkers</code> which are child
scopes will update their markers.</p></li>
</ul>
<h4 id="Example">Example</h4>
<div class="example"><pre><code class="js">$scope.$broadcast('gmMarkersUpdate', 'myObjects');
</code></pre></div>
</div>
</li>
<li><h3 id="gmMarkersUpdated">gmMarkersUpdated</h3>
<div class="gmmarkersupdated"><p>Emitted when markers are updated.</p><div class="inline"><h4 id="Type.">Type:</h4>
<div class="type-">emit</div>
</div>
<div class="inline"><h4 id="Target.">Target:</h4>
<div class="target-">current gmMarkers scope</div>
</div>
<h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">objects – {string} – </code>
<p>the name of the scope variable which holds the
objects the <code>gmMarkers</code> directive was constructed with. This is what
<code>gm-objects</code> was set to.</p></li>
</ul>
<h4 id="Example">Example</h4>
<div class="example"><pre><code class="js">$scope.$on('gmMarkersUpdated', function(event, objects) {
    if (objects === 'myObjects') {
      ...
    }
});
</code></pre></div>
</div>
</li>
</ul>
</div>
</div>
